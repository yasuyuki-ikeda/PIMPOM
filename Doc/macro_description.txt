I(n,x,y)

<引数> 　
【数値】n 画像メモリ番号
【数値】x x座標
【数値】y y座標

<戻り値> 
【数値】画像メモリn番の(x,y)座標の濃度値
　　　　x,yをサブピクセルで指定した場合は、bi-linear補完した値を返す
	RGB画像の場合は、明度を返す
==============================

sin(x)

<引数> 　
【数値】x

<戻り値> 
【数値】xの正弦
==============================

cos(x)

<引数> 　
【数値】x

<戻り値> 
【数値】xの余弦
==============================

tan(x)

<引数> 　
【数値】x

<戻り値> 
【数値】xの正接
==============================

asin(x)

<引数> 　
【数値】x

<戻り値> 
【数値】xの逆正弦
==============================

acos(x)

<引数> 　
【数値】x

<戻り値> 
【数値】xの逆余弦
==============================

atan(x)

<引数>   
【数値】x

<戻り値> 
【数値】xの逆正接
==============================

atan2(x,y)

<引数>   
【数値】x 
【数値】y

<戻り値> 
【数値】x/yの逆正接
==============================

log(x)

<引数>   
【数値】x

<戻り値> 
【数値】xの対数
==============================

sqrt(x)

<引数>    
【数値】x

<戻り値>  
【数値】xの平方根
==============================

exp(x)

<引数>    
【数値】x

<戻り値>  
【数値】e（自然対数の底）のx乗
==============================

abs(x)

<引数>   
【数値】x

<戻り値> 
【数値】xの絶対値
==============================

ceil(x)

<引数>   
【数値】x

<戻り値> 
【数値】xの少数点以下切り上げ
==============================

floor(x)

<引数>   
【数値】x

<戻り値> 
【数値】xの少数点以下切り下げ
==============================

mod(x,y)

<引数>　 
【数値】x
【数値】y

<戻り値> 
【数値】x/yの余剰
==============================

pow(x,y)

<引数>   
【数値】x
【数値】y

<戻り値> 
【数値】xのy乗
==============================

thresh(x,y)

<引数>   
【数値】x
【数値】y

<戻り値> 
【数値】x>yのとき1、それ以外0
==============================

delta(x,y)

<引数>   
【数値】x
【数値】y

<戻り値> 
【数値】x=yのとき1、それ以外0
==============================

PI()

<戻り値> 
【数値】円周率
==============================

random()

<戻り値> 
【数値】0～1の一様分布で乱数
==============================

rand()

<戻り値> 
【数値】ANSI-Cの乱数
==============================

gaus()

<戻り値> 
【数値】標準偏差1のガウス分布で乱数
==============================

max(x0,x1,....)

<引数>   
【数値】x0,x1,,,
　引数の数は2～10

<戻り値> 
【数値】x0,x1,...で最大のもの
==============================

min(x0,x1,....)

<引数>   
【数値】x0,x1,,,
　引数の数は2～10

<戻り値> 
【数値】x0,x1,...で最小のもの
==============================

dist(x0,y0,x1,y1)

<引数>   
【数値】x0        点0のx座標
【数値】y0        点0のy座標
【数値】x1        点1のx座標
【数値】y1        点1のy座標

<戻り値> 
【数値】2点のユークリッド距離
==============================

A(n,x,y)

<引数>   
【数値】n         画像メモリ番号
【数値】x         y座標
【数値】y         x座標

<戻り値> 
【数値】画像の濃度値を取得する
==============================

sigmoid(x,k)

<引数>   
【数値】x  
【数値】k  

<戻り値> 
【数値】1 / (1 + exp(-x*k))
==============================

ReLU(x)

<引数>   
【数値】x  

<戻り値> 
【数値】x > 0の場合はx, x<=0の場合は0
==============================

GetDataUnitNumber()

<戻り値> 
【数値】画像メモリの最大数
==============================

GetCurrentImageNumber()

<戻り値> 
【数値】現在選択中の画像メモリ番号
==============================

SetCurrentImageNumber(n)

<引数>     
【数値】n  画像メモリ番号　
　 
<戻り値> 　
【数値】0

<機能>　　 選択画像メモリの番号を設定する
==============================

GetDataTypeSize(n , t)

<引数>   　
【数値】n  画像メモリ番号
【数値】t  取得するデータの種類
            (0:型(*)  1:画像幅  2:画像高さ  3:ページ数)

<戻り値> 　
【数値】所望のデータ

<機能>　　 画像データの型／高さ／幅／ページ数を取得する

 *画像データの型=1画素あたりのデータの種類
                　0:8bit  1:浮動小数点  2:複素数  3:3D(動画)  4:FLOAT 3D(動画)
                  5:XY分布  6:XYZ分布  7:RGBカラー  8:符号なし16bit  9:符号つき32bit
                  10:RGB 3D(動画) 11:符号付き16bit  12:符号なし32bit
==============================

CopyDataUnit(src, dst)

<引数>
【数値】src   コピー元画像メモリ番号
【数値】dst   コピー先画像メモリ番号

<戻り値> 　
【数値】0

<機能>　　 src番の画像メモリをdst番にコピーする
==============================

DeleteDataUnit(n)

<引数> 　　
【数値】n  対象画像メモリ番号

<戻り値> 　
【数値】0

<機能>　　 画像メモリを削除する
==============================

BackupDataUnit(n)

<引数>　　 
【数値】n  対象画像メモリ番号

<戻り値> 　
【数値】0

<機能> 　　画像メモリをバックアップ領域に入れる
==============================

RecoverDataUnit(n)

<引数> 　　
【数値】n  対象画像メモリ番号

<戻り値> 　
【数値】0

<機能> 　　バックアップ領域から画像メモリを復元する
==============================

ConvertDataUnit(n, type_to, rgb_to, comp_to, satulate, byte_from_disp, color_gray)

<引数> 　　
【数値】n               対象画像メモリ番号      
【数値】type_to         変換後の画像メモリの型(*)      
【数値】rgb_to          RGBに変換する場合の挿入先 （1:R成分 2:G成分 3:B成分 1-3以外:RGB全成分）      
【数値】comp_to         複素数に変換する場合の挿入先（0:実部　0以外:虚部）      
【数値】satulate        型の上下限を超える値を変換するとき飽和させるかどうか (0:折り返す 0以外:飽和する)     
【数値】byte_from_disp  BYTEに変換する場合、表示メモリorマスクから変換するかどうか (0:画像データ 1:表示メモリ 2:マスク 3:疑似カラー)
【数値】color_gray      RGB->グレー変換方法 (1:彩度 2:色相  これら以外:明度)

<戻り値> 　
【数値】0

<機能>   　画像メモリの型を変換する

 *画像データの型=1画素あたりのデータの種類
                　0:8bit  1:浮動小数点  2:複素数  3:3D(動画)  4:FLOAT 3D(動画)
                  5:XY分布  6:XYZ分布  7:RGBカラー  8:符号なし16bit  9:符号つき32bit
                  10:RGB 3D(動画) 11:符号付き16bit  12:符号なし32bit
==============================

ConvertDispToByte(n)

<引数> 　　
【数値】n  対象画像メモリ番号

<戻り値> 　
【数値】0

<機能>   　画像データの型をBYTEに変換する
==============================

GetSrcFilePath(n)

<引数> 　　
【数値】n  画像メモリ番号

<戻り値> 　
【文字列】読み込まれたファイルのパス

<機能>   　ファイルから読み込まれた画像メモリに対し、読み込み元のファイルの存在するディレクトリパスを返す
==============================

GetSrcFileName(n)

<引数> 　　
【数値】n  画像メモリ番号

<戻り値> 　
【文字列】読み込まれたファイル名

<機能>   　ファイルから読み込まれた画像メモリに対し、読み込み元のファイルの名前を返す

==============================

GetSrcFileTitle(n)

<引数> 　　
【数値】n  画像メモリ番号

<戻り値> 　
【文字列】読み込まれたファイルのタイトル（ファイル名から拡張子を抜いたもの）

<機能>   　ファイルから読み込まれた画像メモリに対し、読み込み元のファイルのタイトルを返す

==============================

GetSrcFilePathName(n)

<引数> 　　
【数値】n  画像メモリ番号

<戻り値> 　
【文字列】読み込まれたファイルパス

<機能>   　ファイルから読み込まれた画像メモリに対し、読み込み元のファイルのフルパスを返す
==============================

FormatDataUnit(n, type, width, height, page)

<引数> 　　
【数値】n      画像メモリ番号
【数値】type   画像データの型*
【数値】width  画像データの幅
【数値】height 画像データの高さ
【数値】page   画像データの奥行

<戻り値> 　
【数値】0

<機能>   　画像メモリを新しくとりなおし、0で初期化

 *画像データの型=1画素あたりのデータの種類
                　0:8bit  1:浮動小数点  2:複素数  3:3D(動画)  4:FLOAT 3D(動画)
                  5:XY分布  6:XYZ分布  7:RGBカラー  8:符号なし16bit  9:符号つき32bit
                  10:RGB 3D(動画) 11:符号付き16bit  12:符号なし32bit
==============================

GetDataMinMax(n , t)

<引数>   　
【数値】n  画像メモリ番号
【数値】t  取得するデータの種類
            (0:最小値  1:最大値)

<戻り値> 　
【数値】所望のデータ

<機能>　　 画像データの最大値／最小値を取得する
==============================

SetDispPage(n, page)

<引数> 　　
【数値】n        画像メモリ番号      
【数値】page     表示するページ番号

<戻り値> 　
【数値】0

<機能>   　 画像表示のページ番号を設定する

==============================

SetDispChannel(n, channel)

<引数> 　　
【数値】n        画像メモリ番号      
【数値】channel  表示するチャネル番号(R:0 G:1 B:2 RGB:-1)

<戻り値> 　
【数値】0

<機能>   　 画像表示のチャネル番号を設定する(RGBカラー画像のみ)


==============================

UseWorkArea(n, use)

<引数> 　　
【数値】n        画像メモリ番号      
【数値】use      0以外: 作業領域を使う 0:作業領域を使わない

<戻り値> 　
【数値】0

<機能>   　 作業領域の使用・不使用を変更

==============================

DrawImage(n, name, adjust)
DrawImage(n)

<引数> 　　
【数値】n        画像メモリ番号      
【文字列】name   画像データ名      
【数値】adjust   0以外の場合、表示サイズをメイン画面サイズにあわせる

<戻り値> 
【数値】0

<機能>   　画像表示をおこなう
==============================

ScaleImage(n, scale)

<引数> 　　
【数値】n        画像メモリ番号
【数値】scale    画像表示の拡大率

<戻り値> 
【数値】0

<機能>   　画像表示の拡大率を変更する
==============================

SetDispRange(n, min, max)

<引数> 　　
【数値】n        画像メモリ番号      
【数値】min      画像表示の最小濃度　
【数値】max      画像表示の最大濃度

<戻り値> 　
【数値】0

<機能>   　 画像表示の濃度上限／下限値を設定する
==============================

SetDispRangeAuto(n, type)

<引数> 　　
【数値】n        画像メモリ番号   
【数値】type     設定方法  （ 0:最大/最小 1:平均値±標準偏差×2）

<戻り値> 　
【数値】0

<機能>   　 画像表示の濃度上限／下限値を自動で設定する
==============================

SetWorkArea(n, fig_n, left, top, right, bottom, or_not)

<引数> 　
【数値】n        画像メモリ番号      
【数値】fig_n    作業領域の図形番号    
【数値】left     作業領域左上x座標    
【数値】top      作業領域左上y座標    
【数値】right    作業領域右下x座標      
【数値】bottom   作業領域右下y座標 
【数値】or_not   作業領域のOR/Not区別（0以外:OR  0:NOT）

<戻り値> 　
【数値】0

<機能>   　 矩形の作業領域を設定する
==============================

GetWorkAreaVtx(n, fig_n, vtx_id)

<引数> 　　
【数値】n        画像メモリ番号      
【数値】fig_n    作業領域の図形番号 
【数値】vtx_id   取得する座標の種類（0:左上x 1:左上y 2:右下x 3:右下y）
   
<戻り値> 　
【数値】所望の頂点座標値

<機能>   　 矩形の作業領域の頂点座標を取得する
==============================

GetWorkAreaOrnot(n, fig_n)

<引数> 　　
【数値】n        画像メモリ番号 
【数値】fig_n    作業領域の図形番号
   
<戻り値> 
【数値】作業領域のOR/Not区別（0以外:OR  0:NOT）

<機能>   　 矩形の作業領域のOR/Not区別を取得する
==============================

ChangePalette(n, palette_id)

<引数> 　　
【数値】n        画像メモリ番号 
【数値】palette_id    カラーパレット番号
   
<戻り値> 
【数値】0

<機能>   カラーパレットを変更する
   0:グレースケール
   1:グレースケール反転
   2:Ｂ→Ｇ→Ｒに滑らかに変化
   3:Ｂ→Ｇ→Ｒに滑らかに変化。0未満は黒
   4:正弦波状の濃度変化
   5:Ｂ→Ｙに滑らかに変化
   6:Ｇ→Ｒに滑らかに変化
   7:濃度１ごとに表示色が大きく変化する(ラベル用)

==============================

AddMark(n, x, y)

<引数> 　　
【数値】n        画像メモリ番号    
【数値】x        マーク座標x   
【数値】y        マーク座標y
   
<戻り値> 
【数値】マーク番号

<機能>   　 マークを１点追加する
==============================

AddLineMark(n, x0, y0, x1, y1)

<引数> 　　
【数値】n        画像メモリ番号    
【数値】x0        マーク始点座標x   
【数値】y0        マーク始点座標y
【数値】x1        マーク終点座標x   
【数値】y1        マーク終点座標y

<戻り値> 
【数値】マーク番号

<機能>   　 線マークを1本追加する
==============================


DeleteMark(n, m)

<引数> 　　
【数値】n        画像メモリ番号  
【数値】m        マーク番号   
   
<戻り値> 
【数値】0

<機能>   　 マークを１点削除する
==============================

GetMarkVal(n, m, t)

<引数> 　　
【数値】n        画像メモリ番号  
【数値】m        マーク番号   
【数値】t        取得したいデータの種類
                 (0:x座標 1:y座標 2:画像の濃度値)
<戻り値> 
【数値】所望のデータ

<機能>   　 マークの座標/濃度値を取得する
==============================

GetMarkNumber(n)

<引数> 　　
【数値】n        画像メモリ番号  
   
<戻り値> 
【数値】マークの数

<機能>   　 マークの数を取得する
==============================

ClearMark(n)

<引数> 　　
【数値】n        画像メモリ番号  
   
<戻り値> 
【数値】0

<機能>   　 すべてのマークを削除する
==============================

ChangePallete(n, p)

<引数> 　　
【数値】n        画像メモリ番号  
【数値】p        カラーパレット番号  
                 0:グレースケール
                 1:グレースケール(反転)
                 2:虹色
                 3:虹色(値0は黒)
                 4:コサイン
                 5:青→黄色
                 6:緑→赤
                 7:ラベル
   
<戻り値> 
【数値】0

<機能>   　 カラーパレットの変更をする（RGB表示時は無効）
==============================


ResizeDataUnit(src, dst, new_w, new_h, adjust, offset_x, offset_y, reduce_type)

<引数> 　　
【数値】src       原画像の画像メモリ番号 (-1にした場合は現在選択中の画像)
【数値】dst       結果格納先の画像メモリ番号 (-1にした場合は現在選択中の画像メモリに上書き)
【数値】new_w     リサイズ後の画像メモリ幅 
【数値】new_h     リサイズ後の画像メモリ高さ
【数値】adjust    リサイズに合わせて原画像を拡大/縮小(0以外：する  0:しない)
【数値】offset_x　オフセットx
【数値】offset_y　オフセットy
【数値】reduce_type 縮小アルゴリズム（0:面積平均 1:max値 2:min値）    

<戻り値> 
【数値】0

<機能>   　画像データのサイズ変換する
==============================

ClipDataUnit(src, dst, left, top, right, bottom)

<引数> 　　
【数値】src       原画像の画像メモリ番号 (-1にした場合は現在選択中の画像)
【数値】dst       結果格納先の画像メモリ番号 (-1にした場合は現在選択中の画像メモリに上書き)
【数値】left      クリップ矩形の左上x 
【数値】top       クリップ矩形の左上y 
【数値】right     クリップ矩形の右下x 
【数値】bottom    クリップ矩形の右下y 
    
<戻り値> 
【数値】0

<機能>   　画像データを矩形で切り取る
==============================

PerspectiveTransDataUnit(src, dst, ti, tj, tX, tY, theta, phai, psi, fl_phisical, ccd_pix_size, out_rgn)

<引数> 　　
【数値】src           原画像の画像メモリ番号 (-1にした場合は現在選択中の画像)
【数値】dst           結果格納先の画像メモリ番号 (-1にした場合は現在選択中の画像メモリに上書き)
【数値】ti            CCD平行移動
【数値】tj            CCD平行移動
【数値】tX            撮像面内平行移動
【数値】tY            撮像面内平行移動
【数値】theta         撮像面内回転 [deg]  
【数値】phai          カメラ横方向傾斜 [deg]  
【数値】psi           カメラ縦方向傾斜 [deg]   
【数値】fl_phisical   レンズ焦点距離[mm]
【数値】ccd_pix_size  ccd1画素サイズ[μm]
【数値】out_rgn       画像からはみ出した部分の処理の方法(0:そのまま 1:最近傍画素の値で補間)

<戻り値> 
【数値】0

<機能>   　画像データの射影変換する(ピンホールカメラモデル　ひずみなし)
==============================

IsoTransDataUnit(src, dst, tx, ty, theta, magnify, out_rgn)

<引数> 　　
【数値】src           原画像の画像メモリ番号 (-1にした場合は現在選択中の画像)
【数値】dst           結果格納先の画像メモリ番号 (-1にした場合は現在選択中の画像メモリに上書き)
【数値】tx            平行移動
【数値】ty            平行移動
【数値】theta         回転 [deg]  
【数値】magnify       画像拡大率
【数値】out_rgn       画像からはみ出した部分の処理の方法(0:そのまま 1:最近傍画素の値で補間)

<戻り値> 
【数値】0

<機能>   　画像データの等方変換(回転、平行移動、拡大)する
==============================

CalcDataValue( n, type, width, height, formula ,satulate)　←新しく画像メモリを取得する
CalcDataValue( n, formula ,satulate)　　←既存の画像メモリを上書きする

<引数> 　　
【数値】   n           画像メモリ番号
【数値】   type        作成する画像の型
【数値】   width       作成する画像の幅
【数値】   height      作成する画像の高さ
【文字列】 formula     数式
【数値】satulate       型の上下限を超える値を変換するとき飽和させるかどうか (0:折り返す 0以外:飽和する)   


<戻り値> 
【数値】0

<機能>   　任意の数式で画像データを生成する

 *画像データの型=1画素あたりのデータの種類
                　0:8bit  1:浮動小数点  2:複素数  3:3D(動画)  4:FLOAT 3D(動画)
                  5:XY分布  6:XYZ分布  7:RGBカラー  8:符号なし16bit  9:符号つき32bit
                  10:RGB 3D(動画) 11:符号付き16bit  12:符号なし32bit
==============================

CalcMaskValue( n, formula, mask_max, mask_min)

<引数> 　　
【数値】   n           画像メモリ番号
【文字列】 formula     数式
【数値】mask_max       マスクOFFとする最大値
【数値】mask_min       マスクOFFとする最小値  


<戻り値> 
【数値】0

<機能>   　任意の数式でマスクを設定する

==============================


FilterSmooth(src, dst, fw, fh, cut_min_max, multi)

<引数> 　　
【数値】src           原画像の画像メモリ番号 (-1にした場合は現在選択中の画像)
【数値】dst           結果格納先の画像メモリ番号 (-1にした場合は現在選択中の画像メモリに上書き)
【数値】fw            フィルタ幅(3以上)
【数値】fh            フィルタ高さ(3以上)
【数値】cut_min_max   上下限値を除去（0以外：する 0:しない）
【数値】multi         複数チャネル／ページを持つ画像は全てのチャネル／ページを対象とする(1:する 0:現在表示中のもののみ)

<戻り値> 
【数値】0

<機能>   　画像データに移動平均フィルタをかける
==============================

FilterGauss(src, dst, fs,dir, pad, multi)

<引数> 　　
【数値】src           原画像の画像メモリ番号 (-1にした場合は現在選択中の画像)
【数値】dst           結果格納先の画像メモリ番号 (-1にした場合は現在選択中の画像メモリに上書き)
【数値】fs            フィルタサイズ(3以上)
【数値】dir           フィルタ方向 　（1:横のみ 2:縦のみ  それ以外:両方）
【数値】pad           画像外周部でのpadding方法　（1:外周画素で埋める 2:折り返す それ以外:0を入れる）
【数値】multi         複数チャネル／ページを持つ画像は全てのチャネル／ページを対象とする(1:する 0:現在表示中のもののみ)

<戻り値> 
【数値】0

<機能>   　画像データにガウシアンフィルタをかける
           3σがフィルタサイズになるようにする

           カーネル:
               σ = (filter_size-1)/6
                G(x,y) = exp( - x^2 / 2σ^2 )

           [濃度]= conv{ I(x,y), G(x,y) }
==============================

FilterGaussUnshade(src, dst, fs, offset, contrast, dir, pad, multi)

<引数> 　　
【数値】src           原画像の画像メモリ番号 (-1にした場合は現在選択中の画像)
【数値】dst           結果格納先の画像メモリ番号 (-1にした場合は現在選択中の画像メモリに上書き)
【数値】fs            フィルタサイズ(3以上)
【数値】offset        濃度オフセット
【数値】contrast      濃度コントラスト
【数値】dir           フィルタ方向 　（1:横のみ 2:縦のみ  それ以外:両方）
【数値】pad           画像外周部でのpadding方法　（1:外周画素で埋める 2:折り返す それ以外:0を入れる）
【数値】multi         複数チャネル／ページを持つ画像は全てのチャネル／ページを対象とする(1:する 0:現在表示中のもののみ)

<戻り値> 
【数値】0

<機能>   　原画像とガウシアンフィルタ後画像との差分によるシェーディング除去
　　　　　[濃度] = ( G(x,y) - I(x,y) + offset )*contrast
              (I(x,y)は原画像の濃度、G(x,y)はガウシアンフィルタ後の濃度を表す)
==============================

FilterMedian(src, dst, fw, fh, circle_mask, multi)

<引数> 　　
【数値】src           原画像の画像メモリ番号 (-1にした場合は現在選択中の画像)
【数値】dst           結果格納先の画像メモリ番号 (-1にした場合は現在選択中の画像メモリに上書き)
【数値】fw            フィルタ幅(3以上)
【数値】fh            フィルタ高さ(3以上)
【数値】circle_mask   フィルタ形状を円形にする(0以外：する 0:しない)
【数値】multi         複数チャネル／ページを持つ画像は全てのチャネル／ページを対象とする(1:する 0:現在表示中のもののみ)

<戻り値> 
【数値】0

<機能>   　画像データにメディアンフィルタをかける
           フィルタ形状円形はfw,fhがともに奇数のときのみ有効
==============================

FilterErosion(src, dst, fw, fh, circle_mask, multi)

<引数> 　　
【数値】src           原画像の画像メモリ番号 (-1にした場合は現在選択中の画像)
【数値】dst           結果格納先の画像メモリ番号 (-1にした場合は現在選択中の画像メモリに上書き)
【数値】fw            フィルタ幅(3以上)
【数値】fh            フィルタ高さ(3以上)
【数値】circle_mask   フィルタ形状を円形にする(0以外：する 0:しない)
【数値】multi         複数チャネル／ページを持つ画像は全てのチャネル／ページを対象とする(1:する 0:現在表示中のもののみ)

<戻り値> 
【数値】0

<機能>   　画像データに収縮フィルタをかける
           フィルタ形状円形はfw,fhがともに奇数のときのみ有効
==============================

FilterDilation(src, dst, fw, fh, circle_mask, multi)

<引数> 　　
【数値】src           原画像の画像メモリ番号 (-1にした場合は現在選択中の画像)
【数値】dst           結果格納先の画像メモリ番号 (-1にした場合は現在選択中の画像メモリに上書き)
【数値】fw            フィルタ幅(3以上)
【数値】fh            フィルタ高さ(3以上)
【数値】circle_mask   フィルタ形状を円形にする(0以外：する 0:しない)
【数値】multi         複数チャネル／ページを持つ画像は全てのチャネル／ページを対象とする(1:する 0:現在表示中のもののみ)

<戻り値> 
【数値】0

<機能>   　画像データに膨張フィルタをかける
           フィルタ形状円形はfw,fhがともに奇数のときのみ有効
==============================

FilterOpening(src, dst, fw, fh, circle_mask, multi)

<引数> 　　
【数値】src           原画像の画像メモリ番号 (-1にした場合は現在選択中の画像)
【数値】dst           結果格納先の画像メモリ番号 (-1にした場合は現在選択中の画像メモリに上書き)
【数値】fw            フィルタ幅(3以上)
【数値】fh            フィルタ高さ(3以上)
【数値】circle_mask   フィルタ形状を円形にする(0以外：する 0:しない)
【数値】multi         複数チャネル／ページを持つ画像は全てのチャネル／ページを対象とする(1:する 0:現在表示中のもののみ)

<戻り値> 
【数値】0

<機能>   　画像データにオープニングフィルタをかける
           フィルタ形状円形はfw,fhがともに奇数のときのみ有効
==============================

FilterClosing(src, dst, fw, fh, circle_mask, multi)

<引数> 　　
【数値】src           原画像の画像メモリ番号 (-1にした場合は現在選択中の画像)
【数値】dst           結果格納先の画像メモリ番号 (-1にした場合は現在選択中の画像メモリに上書き)
【数値】fw            フィルタ幅(3以上)
【数値】fh            フィルタ高さ(3以上)
【数値】circle_mask   フィルタ形状を円形にする(0以外：する 0:しない)
【数値】multi         複数チャネル／ページを持つ画像は全てのチャネル／ページを対象とする(1:する 0:現在表示中のもののみ)

<戻り値> 
【数値】0

<機能>   　画像データにクロージングフィルタをかける
           フィルタ形状円形はfw,fhがともに奇数のときのみ有効
==============================

FilterBilateral(src, dst, fs, vsigma, dsigma, multi)

<引数> 　　
【数値】src           原画像の画像メモリ番号 (-1にした場合は現在選択中の画像)
【数値】dst           結果格納先の画像メモリ番号 (-1にした場合は現在選択中の画像メモリに上書き)
【数値】fs            フィルタサイズ(3以上)
【数値】vsigma        値のσ*
【数値】dsigma        距離のσ**
【数値】multi         複数チャネル／ページを持つ画像は全てのチャネル／ページを対象とする(1:する 0:現在表示中のもののみ)

<戻り値> 
【数値】0

<機能>   　画像データにバイラテラルフィルタをかける

*vsigma :このパラメータが大きくなると，ピクセル近傍内にある，色的により遠くのピクセルが混ぜ合わせられ，結果として同じような色の領域がより大きくなります．

*dsigma : このパラメータが大きくなると，より遠くのピクセル同士が影響を及ぼしあいます（ただし，それらの色が十分に近い場合に限ります

==============================

FilterGabor(src, dst, fs, gamma, freq, theta, psi, offset, contrast, pad, multi)

<引数> 　　
【数値】src           原画像の画像メモリ番号 (-1にした場合は現在選択中の画像)
【数値】dst           結果格納先の画像メモリ番号 (-1にした場合は現在選択中の画像メモリに上書き)
【数値】fs            フィルタサイズ (3以上)
【数値】gamma         カーネル扁平率γ
【数値】freq          カーネル内での周期
【数値】theta         カーネル回転角度θ[deg]
【数値】psi           カーネル位相Ψ[deg]
【数値】offset        濃度オフセット
【数値】contrast      濃度コントラスト
【数値】pad           画像外周部でのpadding方法　（1:外周画素で埋める 2:折り返す それ以外:0を入れる）
【数値】multi         複数チャネル／ページを持つ画像は全てのチャネル／ページを対象とする(1:する 0:現在表示中のもののみ)

<戻り値> 
【数値】0

<機能>   　画像データにガボールフィルタをかける

           カーネル：
                 xt = cos(πθ/180)x + sin(πθ/180)y
                 yt = -sin(πθ/180)x + cos(πθ/180)y 
                 σ=(fs-1)/3
                 λ=fs/freq
　　　　　　　　 Gabor(x,y) = exp( - (xt^2 + γ^2 yt^2) / 2σ^2 ) cos( 2πxt/λ + πΨ/180)

                 上式で算出後、平均0になるように正規化

           [濃度] =  conv{I(x,y) , Gabor(x,y)} * contrast + offset
                 (I(x,y)は元画像の濃度、conv{a,b}はaとbの畳み込み)
==============================

FilterEdgeSigmoid(src, dst, fs, k, theta, offset, contrast, pad, multi)

<引数> 　　
【数値】src           原画像の画像メモリ番号 (-1にした場合は現在選択中の画像)
【数値】dst           結果格納先の画像メモリ番号 (-1にした場合は現在選択中の画像メモリに上書き)
【数値】fs            フィルタサイズ (3以上)
【数値】k             パラメタk
【数値】theta         カーネル回転角度θ[deg]
【数値】offset        濃度オフセット
【数値】contrast      濃度コントラスト
【数値】pad           画像外周部でのpadding方法　（1:外周画素で埋める 2:折り返す それ以外:0を入れる）
【数値】multi         複数チャネル／ページを持つ画像は全てのチャネル／ページを対象とする(1:する 0:現在表示中のもののみ)

<戻り値> 
【数値】0

<機能>   　画像データにシグモイド関数を畳み込んでエッジ検出する

           カーネル：
                 xt = cos(πθ/180)x + sin(πθ/180)y
　　　　　　　　 Sig(x,y) = 1 / (1 + exp( - k*xt ) ) -0.5


           [濃度] =  conv{I(x,y) , Sig(x,y)} * contrast + offset
                 (I(x,y)は元画像の濃度、conv{a,b}はaとbの畳み込み)
==============================

FilterEdgeSobel(src, dst, fs, th, dir, multi)

<引数> 　　
【数値】src           原画像の画像メモリ番号 (-1にした場合は現在選択中の画像)
【数値】dst           結果格納先の画像メモリ番号 (-1にした場合は現在選択中の画像メモリに上書き)
【数値】fs            フィルタサイズ ( 3: 3x3,  5:5x5,  7:7x7,  9:9x9 )
【数値】th            エッジ強度最小値（この値より小さい場合は0強制的に0にする）
【数値】dir           フィルタ方向 （1:横のみ 2:縦のみ  それ以外:両方）
【数値】multi         複数チャネル／ページを持つ画像は全てのチャネル／ページを対象とする(1:する 0:現在表示中のもののみ)

<戻り値> 
【数値】0

<機能>   　ソーベルフィルタを使って画像データのエッジ抽出する
==============================

FilterLaplaceGauss(src, dst, fs, dir, offset, contrast, pad, multi)

<引数> 　　
【数値】src           原画像の画像メモリ番号 (-1にした場合は現在選択中の画像)
【数値】dst           結果格納先の画像メモリ番号 (-1にした場合は現在選択中の画像メモリに上書き)
【数値】fs            フィルタサイズ (3以上)
【数値】dir           フィルタ方向 （1:横のみ 2:縦のみ  それ以外:両方）
【数値】offset        濃度オフセット
【数値】contrast      濃度コントラスト
【数値】pad           画像外周部でのpadding方法　（1:外周画素で埋める 2:折り返す それ以外:0を入れる）
【数値】multi         複数チャネル／ページを持つ画像は全てのチャネル／ページを対象とする(1:する 0:現在表示中のもののみ)

<戻り値> 
【数値】0

<機能>    画像データにラプラシアンオブガウシアンフィルタをかける
          カーネルのゼロクロス間隔はフィルタサイズの半分とする
          
          カーネル：
             σ = (fs - 1) / 4√2
             LoG(x,y) = (x^2 + y^2 - 2σ^2) exp( - (x^2 + y^2) / 2σ^2 )
               
　　　　　　上式で算出後、最大1,平均0になるように正規化

　　　　　[濃度] =  conv{I(x,y) , LoG(x,y)} * contrast + offset
               (I(x,y)は元画像の濃度、conv{a,b}はaとbの畳み込み)
==============================

FilterEdgeLog(src, dst, fs, th, dir, pad, multi)

<引数> 　　
【数値】src           原画像の画像メモリ番号 (-1にした場合は現在選択中の画像)
【数値】dst           結果格納先の画像メモリ番号 (-1にした場合は現在選択中の画像メモリに上書き)
【数値】fs            フィルタサイズ (3以上)
【数値】th            エッジ強度最小値（この値より小さい場合は0強制的に0にする）
【数値】dir           フィルタ方向 （1:横のみ 2:縦のみ  それ以外:両方）
【数値】pad           画像外周部でのpadding方法　（1:外周画素で埋める 2:折り返す それ以外:0を入れる）
【数値】multi         複数チャネル／ページを持つ画像は全てのチャネル／ページを対象とする(1:する 0:現在表示中のもののみ)

<戻り値> 
【数値】0

<機能>   　ラプラシアンオブガウシアンフィルタ（ゼロクロス検出）を使って画像データのエッジ抽出する
           カーネルのゼロクロス間隔はフィルタサイズの半分とする
==============================

FilterEdgeCanny(src, dst, fs, th, th_w, multi)

<引数> 　　
【数値】src           原画像の画像メモリ番号 (-1にした場合は現在選択中の画像)
【数値】dst           結果格納先の画像メモリ番号 (-1にした場合は現在選択中の画像メモリに上書き)
【数値】fs            フィルタサイズ (3以上)
【数値】th            初期検出用エッジ強度閾値
【数値】th_w          方向判別・接続用エッジ強度閾値(thより小さいこと)
【数値】multi         複数チャネル／ページを持つ画像は全てのチャネル／ページを対象とする(1:する 0:現在表示中のもののみ)

<戻り値> 
【数値】0

<機能>   　Canny法により画像データのエッジ抽出する
　　　　　（この機能は、BYTE型画像にのみ適用可能）
==============================

FilterMirror(src, dst, dir, multi)

<引数> 　　
【数値】src           原画像の画像メモリ番号 (-1にした場合は現在選択中の画像)
【数値】dst           結果格納先の画像メモリ番号 (-1にした場合は現在選択中の画像メモリに上書き)
【数値】dir           反転方向 ( 0:横  1:縦 2:180°回転)
【数値】multi         複数チャネル／ページを持つ画像は全てのチャネル／ページを対象とする(1:する 0:現在表示中のもののみ)

<戻り値> 
【数値】0

<機能>   　画像データを鏡像反転または180°回転する
==============================

FilterNega(src, dst, multi)

<引数> 　　
【数値】src           原画像の画像メモリ番号 (-1にした場合は現在選択中の画像)
【数値】dst           結果格納先の画像メモリ番号 (-1にした場合は現在選択中の画像メモリに上書き)
【数値】multi         複数チャネル／ページを持つ画像は全てのチャネル／ページを対象とする(1:する 0:現在表示中のもののみ)

<戻り値> 
【数値】0

<機能>   　画像データを濃度反転する
           [濃度] = 255 - x
==============================

FilterCLAHE(src, dst, multi)

<引数> 　　
【数値】src           原画像の画像メモリ番号 (-1にした場合は現在選択中の画像)
【数値】dst           結果格納先の画像メモリ番号 (-1にした場合は現在選択中の画像メモリに上書き)
【数値】limit         度数上限値
【数値】tileW         横方向分割数
【数値】tileH         縦方向分割数
【数値】multi         複数チャネル／ページを持つ画像は全てのチャネル／ページを対象とする(1:する 0:現在表示中のもののみ)

<戻り値> 
【数値】0

<機能>   CLAHE (Contrast Limited Adaptive Histogram Equalization)
     https://en.wikipedia.org/wiki/Adaptive_histogram_equalization

==============================

FilterLocalContrast(src, dst, fs, cs, multi)

<引数> 　　
【数値】src           原画像の画像メモリ番号 (-1にした場合は現在選択中の画像)
【数値】dst           結果格納先の画像メモリ番号 (-1にした場合は現在選択中の画像メモリに上書き)
【数値】fs            フィルタサイズ
【数値】cs            コントラストスケール
【数値】multi         複数チャネル／ページを持つ画像は全てのチャネル／ページを対象とする(1:する 0:現在表示中のもののみ)

<戻り値> 
【数値】0

<機能>   　画像データをローカルコントラスト強調する
           [濃度] = 255*( x - ave - cs*σ)/(2*σ)
                 ave: フィルタサイズ近傍画素の濃度平均
                 σ:  フィルタサイズ近傍画素の濃度標準偏差

==============================

Binalize(src, dst, min_th, max_th, inv)

<引数> 　　
【数値】src           原画像の画像メモリ番号 (-1にした場合は現在選択中の画像)
【数値】dst           2値画像格納先の画像メモリ番号
【数値】min_th        濃度最小閾値
【数値】max_th        濃度最大閾値
【数値】inv           2値反転(0以外:する  0:しない)

<戻り値> 
【数値】0

<機能>   　グローバル閾値で画像データを2値化する
==============================

BinalizeThresholdOtsu(src)

<引数> 　　
【数値】src           原画像の画像メモリ番号 (-1にした場合は現在選択中の画像)

<戻り値> 
【数値】2値化閾値

<機能> 判別分析法（大津の手法）により2値化閾値を求める  　
==============================

BinalizeThresholdPTile(src, percent)

<引数> 　　
【数値】src           原画像の画像メモリ番号 (-1にした場合は現在選択中の画像)
【数値】percent       面積何%までにするか
 
<戻り値> 
【数値】2値化閾値

<機能> パーセンタイル法により2値化閾値を求める  　
==============================

BinalizeThresholdPTile(src, percent)

<引数> 　　
【数値】src           原画像の画像メモリ番号 (-1にした場合は現在選択中の画像)
【数値】percent       黒面積を何%にするか
 
<戻り値> 
【数値】2値化閾値

<機能> パーセンタイル法により2値化閾値を求める  　
==============================

BinalizeLocalGauss(src, dst, fs, offset, inv, pad)

<引数> 　　
【数値】src           原画像の画像メモリ番号 (-1にした場合は現在選択中の画像)
【数値】dst           2値画像格納先の画像メモリ番号
【数値】fs            フィルタサイズ (3以上)
【数値】offset        オフセット
【数値】inv           2値反転(0以外:する  0:しない)
【数値】pad           画像外周部でのpadding方法　（1:外周画素で埋める 2:折り返す それ以外:0を入れる）

<戻り値> 
【数値】0

<機能>   　原画像とガウシアンフィルタ後画像との差分画像を2値化
　　　　　  f(x) - x + offset が 0未満のとき、黒画素とする
           (xは原画像の濃度、f(x)はガウシアンフィルタ後の濃度を表す)
==============================

BinalizeLocalLaplaceGauss(src, dst, fs, offset, inv, pad)

<引数> 　　
【数値】src           原画像の画像メモリ番号 (-1にした場合は現在選択中の画像)
【数値】dst           2値画像格納先の画像メモリ番号
【数値】fs            フィルタサイズ (3以上)
【数値】offset        オフセット
【数値】inv           2値反転(0以外:する  0:しない)
【数値】pad           画像外周部でのpadding方法　（1:外周画素で埋める 2:折り返す それ以外:0を入れる）

<戻り値> 
【数値】0

<機能>   　ラプラシアンオブガウシアンフィルタ後の画像を2値化
　　　　　  x + offset が 0未満のとき、黒画素とする（xは原画像の濃度を表す)
==============================

BinalizeNick(src, dst, fs, k, inv)

<引数> 　　
【数値】src           原画像の画像メモリ番号 (-1にした場合は現在選択中の画像)
【数値】dst           2値画像格納先の画像メモリ番号
【数値】fs            フィルタサイズ (3以上)
【数値】k             パラメタk
【数値】inv           2値反転(0以外:する  0:しない)

<戻り値> 
【数値】0

<機能>   　NICKの手法で画像を2値化

　　 NICK法：
   　　以下の式でウィンドウごとにの2値化閾値Tを決める
	     T = ave + k * sqrt{ (∑I^2 + ave^2)/np }

		  I: pixel value
		  ave: averaged pixel value within the window
		  np: number of pixels within the window

==============================

Label(src, dst, sort, min_area)

<引数> 　　
【数値】src           2値画像格納先の画像メモリ番号 (-1にした場合は現在選択中の画像)
【数値】dst           ラベル画像格納先の画像メモリ番号
【数値】sort          面積降順でソートするかどうか(0以外:する  0:しない)
【数値】min_area      ラベリング最小面積

<戻り値> 
【数値】ラベル数

<機能>   　2値画像をラベリングする
==============================

HoughLines(n, pixSkip, dirSkip, voteThresh, minLineLength, maxLineGap)

<引数> 　　
【数値】n             エッジ抽出画像格納先の画像メモリ番号 (-1にした場合は現在選択中の画像)
【数値】pixSkip       投票空間の距離分解能[pix]
【数値】dirSkip       投票空間の角度分解能[deg]
【数値】voteThresh    投票の閾値
【数値】minLineLength 最小線分長
【数値】maxLineGap    最大線分間隔

<戻り値> 
【数値】抽出した線数数

<機能>   　Cannyフィルタなどで抽出したエッジ画像に対し、確率的Hough変換にて直線を抽出する
==============================

BlendPoisson(src, blend, dst, ofsx, ofsy, mode)

<引数> 　　
【数値】src           元画像メモリ番号(-1にした場合は現在選択中の画像)
【数値】blend         ブレンド画像メモリ番号
【数値】dst           結果画像メモリ番号(-1にした場合は現在選択中の画像)
【数値】ofsx          合成開始位置x
【数値】ofsy          合成開始位置y
【数値】mode          合成方法 0: NORMAL_CLONE,  1: MIXED_CLONE  2: MONOCHROME_TRANSFER

<戻り値> 
【数値】成功したら1

<機能>   　濃度勾配を配慮した継ぎ目の少ない画像合成
Patrick P?rez, Michel Gangnet, and Andrew Blake. Poisson image editing. In ACM Transactions on Graphics (TOG), volume 22, pages 313?318. ACM, 2003.
==============================

FilterDFT(src, dst, inv)

<引数> 　
【数値】src           元画像メモリ番号(-1にした場合は現在選択中の画像)
【数値】dst           結果画像メモリ番号
【数値】inv           0：フーリエ変換  0以外:逆フーリエ変換

<戻り値> 
【数値】0

<機能>   　離散フーリエ変換を実行する

==============================

PrepeareDrawing(n, src)

<引数> 　
【数値】n             カラー画像格納先の画像メモリ番号
【数値】src           モノクロ画像の画像メモリ番号

<戻り値> 
【数値】0

<機能>   　モノクロ画像をカラー画像にする
           モノクロ画像上に図形描画する前にこの処理を行う
==============================

DrawLineOnImage(n, sx, sy, ex, ey, pen_size, r, g, b)

<引数> 　
【数値】n             描画対象画像メモリ番号
【数値】sx            始点座標x
【数値】sy            始点座標y
【数値】ex            終点座標x
【数値】ey            終点座標y
【数値】pen_size      線の太さ
【数値】r             描画色赤成分、または濃度
【数値】g             描画色緑成分
【数値】b             描画色青成分

<戻り値> 
【数値】0

<機能>   　画像データ上に直線を描画する
           モノクロ画像上に描画する場合、濃度はrになる
==============================


DrawLineOnImageF(n, a, b, c, pen_size, r, g, b)

<引数> 　
【数値】n             描画対象画像メモリ番号
【数値】a             直線パラメタ
【数値】b             直線パラメタ
【数値】c             直線パラメタ
【数値】pen_size      線の太さ
【数値】r             描画色赤成分、または濃度
【数値】g             描画色緑成分
【数値】b             描画色青成分

<戻り値> 
【数値】0

<機能>   　画像データ上に直線(ax+by+c=0)を描画する
           モノクロ画像上に描画する場合、濃度はrになる
==============================

DrawImageOnImage(n, nd, offsetx, offsety, mixtype)

<引数> 　
【数値】n             下地とする画像メモリ番号
【数値】nd,           描画する画像データが入った画像メモリ番号
【数値】offsetx       描画オフセットx座標
【数値】offsety       描画オフセットy座標
【数値】mixtype       データの合成方法 (1:max, 2:min, other:平均)

<戻り値> 
【数値】0

<機能>   　画像メモリ上に別の画像を描画する

==============================

DrawCursorOnImage(n, x, y, pen_size, r, g, b)

<引数> 　
【数値】n             描画対象画像メモリ番号
【数値】x            座標x
【数値】y            座標y
【数値】pen_size      線の太さ
【数値】r             描画色赤成分、または濃度
【数値】g             描画色緑成分
【数値】b             描画色青成分

<戻り値> 
【数値】0

<機能>   　画像データ上に十字カーソルを描画する
           モノクロ画像上に描画する場合、濃度はrになる
==============================

DrawCircleOnImage(n, x, y, rad, r, g, b, fill)

<引数> 　
【数値】n             描画対象画像メモリ番号
【数値】x             中心点座標x
【数値】y             中心点座標y
【数値】rad           半径
【数値】r             描画色赤成分、または濃度
【数値】g             描画色緑成分
【数値】b             描画色青成分
【数値】fill          内部を塗りつぶすかどうか

<戻り値> 
【数値】0

<機能>   　画像データ上に円を描画する
           モノクロ画像上に描画する場合、濃度はrになる
==============================

DrawRectOnImage(n, left, top, right, bottom, r, g, b, fill)

<引数> 　
【数値】n             描画対象画像メモリ番号
【数値】left          左上x座標    
【数値】top           左上y座標    
【数値】right         右下x座標      
【数値】bottom        右下y座標 
【数値】r             描画色赤成分、または濃度
【数値】g             描画色緑成分
【数値】b             描画色青成分
【数値】fill          内部を塗りつぶすかどうか

<戻り値> 
【数値】0

<機能>   　画像データ上に矩形を描画する
           モノクロ画像上に描画する場合、濃度はrになる
==============================

DrawPointOnImage(n, x, y, size, r, g, b)

<引数> 　
【数値】n             描画対象画像メモリ番号
【数値】x             中心点座標x
【数値】y             中心点座標y
【数値】size          ドットサイズ
【数値】r             描画色赤成分、または濃度
【数値】g             描画色緑成分
【数値】b             描画色青成分

<戻り値> 
【数値】0

<機能>   　画像データ上に矩形のドットを描画する
　　　　　モノクロ画像上に描画する場合、濃度はrになる
==============================

DrawTextOnImage(n, x, y, str, r, g, b)

<引数> 　
【数値】n             描画対象画像メモリ番号
【数値】x             座標x
【数値】y             座標y
【文字列】str         描画するテキスト(ASCIIコードのみ)
【数値】r             描画色赤成分、または濃度
【数値】g             描画色緑成分
【数値】b             描画色青成分

<戻り値> 
【数値】0

<機能>   　画像データ上にテキストを描画する
　　　　　描画できるのはASCIIコードのみ
　　　　　モノクロ画像上に描画する場合、濃度はrになる
==============================

FloodFillOnImage(n, x, y, r, g, b)

<引数> 　
【数値】n             描画対象画像メモリ番号
【数値】x             塗りつぶし開始座標x
【数値】y             塗りつぶし開始座標y
【数値】r             描画色赤成分、または濃度
【数値】g             描画色緑成分
【数値】b             描画色青成分

<戻り値> 
【数値】0

<機能>   　開始座標から同色が続いている領域を描画色でぬりつぶす
　　　　　モノクロ画像上に描画する場合、濃度はrになる
==============================

FillWorkAreaOnImage(n, r, g, b)

<引数> 　
【数値】n             描画対象画像メモリ番号
【数値】r             描画色赤成分、または濃度
【数値】g             描画色緑成分
【数値】b             描画色青成分

<戻り値> 
【数値】0

<機能>   　作業領域内部の画像データを描画色で塗りつぶす
　　　　　モノクロ画像上に描画する場合、濃度はrになる
==============================

FillWorkAreaOnMask(n, v)

<引数> 　
【数値】n             描画対象画像メモリ番号
【数値】v             描画値　1:マスクあり 0:マスクなし それ以外の値：マスクなし

<戻り値> 
【数値】0

<機能>   　作業領域内部のマスクを指定値で塗りつぶす
==============================

DrawLine(sx, sy, ex, ey, pen_size, r, g, b)

<引数> 　
【数値】sx            始点座標x
【数値】sy            始点座標y
【数値】ex            終点座標x
【数値】ey            終点座標y
【数値】pen_size      線の太さ
【数値】r             描画色赤成分
【数値】g             描画色緑成分
【数値】b             描画色青成分

<戻り値> 
【数値】0

<機能>   　メインウィンドウ上に直線を描画する
==============================

DrawCursor(x, y, pen_size, r, g, b)

<引数> 　
【数値】x             座標x
【数値】y             座標y
【数値】pen_size      線の太さ
【数値】r             描画色赤成分、または濃度
【数値】g             描画色緑成分
【数値】b             描画色青成分

<戻り値> 
【数値】0

<機能>   　メインウィンドウ上に十字カーソルを描画する
==============================

DrawRect(left, top, right, bottom, pen_size, r, g, b)

<引数> 　
【数値】left          左上x座標    
【数値】top           左上y座標    
【数値】right         右下x座標      
【数値】bottom        右下y座標 
【数値】pen_size      線の太さ
【数値】r             描画色赤成分、または濃度
【数値】g             描画色緑成分
【数値】b             描画色青成分

<戻り値> 
【数値】0

<機能>   　メインウィンドウ上に矩形を描画する
==============================

DrawCircle(x, y, rad, pen_size, r, g, b)

<引数> 　
【数値】x             中心点座標x
【数値】y             中心点座標y
【数値】rad           半径
【数値】pen_size      線の太さ
【数値】r             描画色赤成分、または濃度
【数値】g             描画色緑成分
【数値】b             描画色青成分

<戻り値> 
【数値】0

<機能>   　メインウィンドウ上に円を描画する
==============================

DrawEllipse(x, y, rx, ry, pen_size, r, g, b)

<引数> 　
【数値】x             中心点座標x
【数値】y             中心点座標y
【数値】rx            x方向半径
【数値】ry            y方向半径
【数値】pen_size      線の太さ
【数値】r             描画色赤成分、または濃度
【数値】g             描画色緑成分
【数値】b             描画色青成分

<戻り値> 
【数値】0

<機能>   　メインウィンドウ上に楕円を描画する
==============================

DrawText(x, y, str, r, g, b, font_size)

<引数> 　
【数値】x             座標x
【数値】y             座標y
【文字列】str         描画するテキスト
【数値】r             描画色赤成分、または濃度
【数値】g             描画色緑成分
【数値】b             描画色青成分
【数値】font_size     フォントサイズ

<戻り値> 
【数値】0


<機能>   　メインウィンドウ上にテキストを描画する
==============================

ClipSegment(x0, y0, x1, y1, left, top, right, bottom, vtx_id)

<引数> 　　
【数値】x0       線分始点X
【数値】y0       線分始点Y
【数値】x1       線分終点X
【数値】y1       線分終点Y
【数値】left     矩形領域左上Y
【数値】top      矩形領域左上Y
【数値】right    矩形領域右下X
【数値】bottom   矩形領域右下Y 
【数値】vtx_id   取得する座標の種類（0:左上x 1:左上y 2:右下x 3:右下y）
   
<戻り値> 　
【数値】所望の頂点座標値

<機能>   　 直線を矩形領域で切り取る
==============================

ClipSegmentF(a, b, c, left, top, right, bottom, vtx_id)

<引数> 　　
【数値】a        ax+by+c=0
【数値】b        
【数値】c        
【数値】left     矩形領域左上Y
【数値】top      矩形領域左上Y
【数値】right    矩形領域右下X
【数値】bottom   矩形領域右下Y 
【数値】vtx_id   取得する座標の種類（0:左上x 1:左上y 2:右下x 3:右下y）
   
<戻り値> 　
【数値】所望の頂点座標値

<機能>   　 直線を矩形領域で切り取る
==============================


ShowMessage(clr, id, str)

<引数> 　
【数値】clr           過去のメッセージをクリアするかどうか (0以外:クリア 0:過去のメッセージのあとに続けて表示)
【数値】id            メッセージ領域番号(0,1)
【文字列】str         テキスト

<戻り値> 
【数値】0


<機能>   　メインウィンドウのメッセージ領域にテキストを表示する
==============================

MessageBox(str)

<引数> 　
【文字列】str         テキスト

<戻り値> 
【数値】0


<機能>   　メッセージボックスを表示する
==============================

CopyToClipbord(n)

<引数> 　
【数値】n            画像メモリ番号

<戻り値> 
【数値】0


<機能>   　表示画像をクリップボードにコピーする
==============================

PasteFromClipbord(n)

<引数> 　
【数値】n            画像メモリ番号

<戻り値> 
【数値】0


<機能>   　クリップボードにある画像をメモリに入れる
           画像データの型はRGBカラーになる
==============================

ToString(x, order)

<引数> 　
【数値】x            
【数値】order        桁数固定

<戻り値> 
【文字列】変換後の文字列


<機能>   　数値データを文字列データにする
==============================

ToNumber(str)

<引数> 　
【数値】str            

<戻り値> 
【文字列】変換後の数値


<機能>   　文字列データを数値データにする
==============================

GetBatchInput(pid)

<引数> 　
【数値】pid         入力パラメタ番号           

<戻り値> 
【数値】バッチ実行の入力パラメタ


<機能>   　バッチ実行ウィンドウと同時使用時、
           バッチ実行の入力パラメタを取得する
==============================

SetBatchInput(pid)

<引数> 　
【数値】pid         入力パラメタ番号           
【数値】val         設定値 

<戻り値> 
【数値】バッチ実行の入力パラメタ


<機能>   　バッチ実行ウィンドウと同時使用時、
           バッチ実行の入力パラメタを設定する
==============================

GetBatchOutput(pid, val)

<引数> 　
【数値】pid         出力パラメタ番号     

<戻り値> 
【数値】0


<機能>   　バッチ実行ウィンドウと同時使用時、
           バッチ実行の出力パラメタを取得する
==============================

SetBatchOutput(pid, val)

<引数> 　
【数値】pid         出力パラメタ番号     
【数値】val         設定値    

<戻り値> 
【数値】0


<機能>   　バッチ実行ウィンドウと同時使用時、
           バッチ実行の出力パラメタを設定する
==============================

UserDlgBatchExecute(pid)

<引数> 　
【数値】pid         カスタムファンクション番号

<戻り値> 
【数値】0

<機能>   　カスタムファンクションを実行する
==============================

CaptureOne()

<戻り値> 
【数値】0

<機能>   　画像を1回キャプチャする

==============================

OpenFileDialog(file_path)

<引数> 　
【文字列】file_path   ファイルの種類
                （例)    テキスト|*.TXT

<戻り値> 
【文字列】ファイルのパス  

<機能>   　ファイルを開くダイアログボックスを表示する

==============================

FolderDialog()

<引数> 　なし
<戻り値> 
【文字列】フォルダのパス  

<機能>   　フォルダを開くダイアログボックスを表示する

==============================


SelectAndLoadImageFile(n, file_path)

<引数> 　
【数値】n             画像メモリ番号
【文字列】file_path   ファイルのパス   

<戻り値> 
【数値】0


<機能>   　画像ファイルを読み込む
           画像データの種類はファイル名の拡張子から判断する
==============================

SelectAndSaveImageFile(n, file_path)

<引数> 　
【数値】n             画像メモリ番号
【文字列】file_path   ファイルのパス   

<戻り値> 
【数値】0


<機能>   　画像ファイルを保存する
           画像データの種類はファイル名の拡張子から判断する
==============================

SaveViewAsBitmap(n, file_path)

<引数> 　
【数値】n             画像メモリ番号
【文字列】file_path   ファイルのパス   

<戻り値> 
【数値】0

<機能>   　表示画像をビットマップとして保存する
==============================

SaveArchivedImage(n, file_path)

<引数> 　
【数値】n             画像メモリ番号
【文字列】file_path   ファイルのパス   

<戻り値> 
【数値】0

<機能>   　画像データをアーカイブファイルとして保存する
==============================

LoadBitmap(n, file_path, x, y, w, h)

<引数> 　
【数値】n             画像メモリ番号
【文字列】file_path   ファイルのパス   
【数値】x             部分読み込み開始位置X
【数値】y             部分読み込み開始位置Y
【数値】w             部分読み込み幅
【数値】h             部分読み込み高さ

<戻り値> 
【数値】0

<機能>   　画像データをビットマップファイルから領域指定で読み出す
==============================


GetDefaultPath()   

<戻り値> 
【文字列】pimpom.exeの絶対パス
==============================

EnumFiles(enum_id, dir_path, file_ext)

<引数> 　
【数値】       enum_id    列挙ID
【文字列】     dir_path   ファイル列挙するディレクトリパス
【文字列】     file_ext   列挙するファイルの拡張子

<戻り値> 
【数値】成功したら1,失敗したら0

<機能>     指定されたディレクトリ内のファイル列挙する
           この関数で列挙されたファイルパスは
           GetNextFilePathでひとつづつ取り出す
==============================

GetNextFilePath(enum_id)

<引数> 　
【数値】       enum_id    列挙ID

<戻り値> 
【文字列】ファイルパス（ファイルが存在しなくなったら""を返す）

<機能>    あらかじめEnumFilesで列挙しておいたファイルパスをひとつづつ取り出す
==============================

CheckFileExist(file_path)

<引数> 　
【文字列】file_path   ファイルのパス  

<戻り値> 
【数値】ファイルが存在する場合は1, 存在しない場合は0
==============================


AddDataToChart(n, val)

<引数> 　
【数値】n             グラフ番号
【数値】val           データ値   

<戻り値> 
【数値】追加したデータ番号

<機能>   　1Dグラフにデータを１点追加する
==============================

AddDataToChart2(n, valx, valy)

<引数> 　
【数値】n             グラフ番号
【数値】valx          データ値   
【数値】valy          データ値

<戻り値> 
【数値】追加したデータ番号

<機能>   　2Dグラフにデータを１点追加する
==============================

ClearChart(n)

<引数> 　
【数値】n             グラフ番号

<戻り値> 
【数値】0

<機能>   　グラフから全データをクリアする
==============================

Res(n)

<引数> 　
【数値】n             行番号

<戻り値> 
【数値】／【文字列】　データ

<機能>   　指定された行の結果を取得する
==============================

ChangeRes(n, val)

<引数> 　
【数値】n             行番号
【数値】val           変更する値

<戻り値> 
【数値】0

<機能>   　指定された行の結果を変更する
==============================

CreateDirectory(path)

<引数> 　
【文字列】path   ディレクトリのパス   

<戻り値> 
【数値】0

<機能>   　ディレクトリを作成する
==============================


WriteText(path, message)

<引数> 　
【文字列】path   　テキストファイルのパス   
【文字列】message　書き出す内容   

<戻り値> 
【数値】0

<機能>   　テキストファイルに上書きモードで書き出す
==============================

AppendText(path, message)

<引数> 　
【文字列】path   　テキストファイルのパス   
【文字列】message　書き出す内容   

<戻り値> 
【数値】0

<機能>   　テキストファイルに追記モードで書き出す
==============================

StrLen(str)

<引数> 　
【文字列】str   　文字列  

<戻り値> 
【数値】文字列の長さ

<機能>   　文字列の長さを取得する
==============================

Substr(str, start, len)

<引数> 　
【文字列】str   元の文字列  
【数値】start   部分文字列の開始位置
【数値】len     部分文字列の長さ

<戻り値> 
【文字列】部分文字列

<機能>   　文字列から部分文字列を切り出す
==============================

FindStr(str, findstr)

<引数> 　
【文字列】str       文字列  
【文字列】findstr   検索対象の文字列  

<戻り値> 
【数値】 検索対象文字列の開始位置（見つからなかった場合は-1）

<機能>   　文字列から検索対象の文字列を探す
==============================

ReplaceStr(str, oldstr, newstr)

<引数> 　
【文字列】str       文字列  
【文字列】oldstr    置換対象の文字列
【文字列】newstr    置き換える文字列

<戻り値> 
【文字列】置換後の文字列

<機能>   　文字列を置換する
==============================

Linear2DataUnit(nA,nB,nDst,type,wA,wB,bias,satulate)

<引数> 
【数値】   nA          画像Aのメモリ番号
【数値】   nB          画像Bのメモリ番号
【数値】   nDst        作成する画像のメモリ番号
【数値】   type        作成する画像の型
【数値】   wA          画像Aに対する重み
【数値】   wB          画像Bに対する重み
【数値】   bias          バイアス
【数値】satulate       型の上下限を超える値を変換するとき飽和させるかどうか (0:折り返す 0以外:飽和する)   

<戻り値> 
【数値】0

<機能> 2画像の線形演算を行う
     [作成する画像] = [画像A] * wA + [画像B] * wB + bias
     
     画像A と 画像Bのサイズが同じでなければいけない
     画像A , 画像B, 作成する画像がRGBカラーの場合は、RGBそれぞれに対して演算をおこなう

 *画像データの型=1画素あたりのデータの種類
                　0:8bit  1:浮動小数点
                  7:RGBカラー  8:符号なし16bit  9:符号つき32bit
                  11:符号付き16bit  12:符号なし32bit
==============================

SumDataUnit(nA,nB,nDst,type,satulate)

<引数> 
【数値】   nA          画像Aのメモリ番号
【数値】   nB          画像Bのメモリ番号
【数値】   nDst        作成する画像のメモリ番号
【数値】   type        作成する画像の型
【数値】satulate       型の上下限を超える値を変換するとき飽和させるかどうか (0:折り返す 0以外:飽和する)   

<戻り値> 
【数値】0

<機能> 2画像の加算を行う
     [作成する画像] = [画像A] + [画像B] 
     
     画像A と 画像Bのサイズが同じでなければいけない
     画像A , 画像B, 作成する画像がRGBカラーの場合は、RGBそれぞれに対して演算をおこなう

 *画像データの型=1画素あたりのデータの種類
                　0:8bit  1:浮動小数点
                  7:RGBカラー  8:符号なし16bit  9:符号つき32bit
                  11:符号付き16bit  12:符号なし32bit
==============================

SubtractDataUnit(nA,nB,nDst,type,satulate)

<引数> 
【数値】   nA          画像Aのメモリ番号
【数値】   nB          画像Bのメモリ番号
【数値】   nDst        \作成する画像のメモリ番号
【数値】   type        作成する画像の型
【数値】satulate       型の上下限を超える値を変換するとき飽和させるかどうか (0:折り返す 0以外:飽和する)   

<戻り値> 
【数値】0

<機能> 2画像の減算を行う
     [作成する画像] = [画像A] - [画像B] 
     
     画像A と 画像Bのサイズが同じでなければいけない
     画像A , 画像B, 作成する画像がRGBカラーの場合は、RGBそれぞれに対して演算をおこなう

 *画像データの型=1画素あたりのデータの種類
                　0:8bit  1:浮動小数点
                  7:RGBカラー  8:符号なし16bit  9:符号つき32bit
                  11:符号付き16bit  12:符号なし32bit
==============================

MultiplyDataUnit(nA,nB,nDst,type,satulate)

<引数> 
【数値】   nA          画像Aのメモリ番号
【数値】   nB          画像Bのメモリ番号
【数値】   nDst        作成する画像のメモリ番号
【数値】   type        作成する画像の型
【数値】satulate       型の上下限を超える値を変換するとき飽和させるかどうか (0:折り返す 0以外:飽和する)   

<戻り値> 
【数値】0

<機能> 2画像の積算を行う
     [作成する画像] = [画像A] * [画像B] 
     
     画像A と 画像Bのサイズが同じでなければいけない
     画像A , 画像B, 作成する画像がRGBカラーの場合は、RGBそれぞれに対して演算をおこなう

 *画像データの型=1画素あたりのデータの種類
                　0:8bit  1:浮動小数点
                  7:RGBカラー  8:符号なし16bit  9:符号つき32bit
                  11:符号付き16bit  12:符号なし32bit
==============================

DivideDataUnit(nA,nB,nDst,type,satulate)

<引数> 
【数値】   nA          画像Aのメモリ番号
【数値】   nB          画像Bのメモリ番号
【数値】   nDst        作成する画像のメモリ番号
【数値】   type        作成する画像の型
【数値】satulate       型の上下限を超える値を変換するとき飽和させるかどうか (0:折り返す 0以外:飽和する)   

<戻り値> 
【数値】0

<機能> 2画像の商算を行う
     [作成する画像] = [画像A] / [画像B] 
     
     画像A と 画像Bのサイズが同じでなければいけない
     画像A , 画像B, 作成する画像がRGBカラーの場合は、RGBそれぞれに対して演算をおこなう

 *画像データの型=1画素あたりのデータの種類
                　0:8bit  1:浮動小数点
                  7:RGBカラー  8:符号なし16bit  9:符号つき32bit
                  11:符号付き16bit  12:符号なし32bit
==============================


LinearDataUnit(n,nDst,type,w,bias,satulate)

<引数> 
【数値】   n           元画像のメモリ番号
【数値】   nDst        作成する画像のメモリ番号
【数値】   type        作成する画像の型
【数値】   w           元画像に対する重み
【数値】   bias        バイアス
【数値】satulate       型の上下限を超える値を変換するとき飽和させるかどうか (0:折り返す 0以外:飽和する)   

<戻り値> 
【数値】0

<機能> 1画像の線形演算を行う
     [作成する画像] = [元画像] * w + bias
     
     元画像と作成する画像がRGBカラーの場合は、RGBそれぞれに対して演算をおこなう

 *画像データの型=1画素あたりのデータの種類
                　0:8bit  1:浮動小数点
                  7:RGBカラー  8:符号なし16bit  9:符号つき32bit
                  11:符号付き16bit  12:符号なし32bit
==============================

AbsDataUnit(n,nDst)

<引数> 
【数値】   n           元画像のメモリ番号
【数値】   nDst        作成する画像のメモリ番号 

<戻り値> 
【数値】0

<機能> 元画像の絶対値をとる
       元画像がRGBカラーの場合は、RGBそれぞれに対して演算をおこなう
==============================

SubAbsDataUnit(nA,nB,nDst,type,satulate)

<引数> 
【数値】   nA          画像Aのメモリ番号
【数値】   nB          画像Bのメモリ番号
【数値】   nDst        作成する画像のメモリ番号
【数値】   type        作成する画像の型
【数値】satulate       型の上下限を超える値を変換するとき飽和させるかどうか (0:折り返す 0以外:飽和する)   

<戻り値> 
【数値】0

<機能> 2画像を減算して絶対値をとる
     [作成する画像] = | [画像A] - [画像B] |
     
     画像A と 画像Bのサイズが同じでなければいけない
     画像A , 画像B, 作成する画像がRGBカラーの場合は、RGBそれぞれに対して演算をおこなう

 *画像データの型=1画素あたりのデータの種類
                　0:8bit  1:浮動小数点
                  7:RGBカラー  8:符号なし16bit  9:符号つき32bit
                  11:符号付き16bit  12:符号なし32bit
==============================

Wait(ms)

<引数> 　
【数値】ms        中断時間[ms]

<戻り値> 
【数値】0

<機能>   　指定された時間にわたって、実行を中断する

==============================


